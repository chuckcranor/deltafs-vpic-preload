#include "binhistogram.h"

namespace pdlfs {
namespace carp {

/*
 * BinHistConsumer: we are given a BinHistogram with total weight "w"
 * (where "w" is the sum of the entries in the binhist's weights_[] vec).
 * in CARP the binhist is either the main one in Carp (in which case
 * the bin type is float and the weight type is uint64_t) or a
 * binhist that is generated by the rtp protocol as the result of
 * a pivot union operation (in which case the bin type is double
 * and the weight type is float).  We start at the first bin and
 * as we consume weight we move to the end of the bins after we've
 * consumed "w" weight.  so our values range from the start (rmin)
 * of the binhist range to the end (rmax).  since a binhist only
 * contains aggregate data, we have to use the bin boundaries to
 * interpolate our current value.
 * The binhist should be locked/protected during our lifetime.
 */

template <typename BT, typename WT> class BinHistConsumer {
 public:
  BinHistConsumer(BinHistogram<BT,WT>* bins) : bins_(bins) {
    if (bins) {
      size_ = bins_->Size();
      wtotal_ = bins_->GetTotalWeight();
      range_ = bins_->GetRange();
    } else {
      size_ = 0;
      wtotal_ = 0;
    }
    wremain_ = wtotal_;          /* nothing consumed yet */
    curloc_ = 0;
    resid_ = (size_) ?  bins_->Weight(0) : 0.0;  /* could be 0 either way */
    curval_ = range_.rmin();
  }

  /* some helpful accessor functions */
  WT TotalWeight() { return wtotal_; }                 /* total weight, >= 0 */
  Range GetRange() { return range_; }                  /* our range */
  double RemainingWeight() { return wremain_; }        /* remaining weight */
  double CurrentValue() { return curval_; }            /* our current value */

  double ConsumeWeightTo(double desired_remaining) {
    double remaining = this->RemainingWeight();
    if (remaining <= desired_remaining) /* already at or past desired value? */
      return remaining;
    return this->ConsumeWeight(remaining - desired_remaining);
  }

  double ConsumeWeight(double consume) {

    do { /* while consume > 0.0 */

      /* drain as much residual as we can */
      if (consume > 0.0 && resid_) {
        double use = (consume < resid_) ? consume : resid_;
        resid_ -= use;
        wremain_ -= use;
        consume -= use;
      }

      if (consume > 0.0) {  /* resid_ must be 0 if we still need more */

        if (curloc_ < size_)           /* advance if room */
          curloc_++;
        if (curloc_ >= size_) {        /* hit the end, stop */
          wremain_ = 0.0;
          curloc_ = size_;             /* don't go past end */
          break;
        }

        resid_ = bins_->Weight(curloc_);  /* on a new bin, reset resid */
      }

    } while (consume > 0.0);

    /* now we need to update curval_ */
    if (curloc_ >= size_) {
      curval_ = range_.rmax();    /* at end or no data (size==0), use rmax */
    } else {
      Range brange = bins_->GetBin(curloc_);
      WT bweight = bins_->Weight(curloc_);
      if (resid_ == bweight) {
        curval_ = brange.rmin();  /* have not consumed any from this bin yet */
      } else {
        double frac = 1.0 - (resid_ / (double) bweight); /* frac !consumed */
        double delta = brange.rmax() - brange.rmin();
        assert(frac >= 0.0 && frac <= 1.0);
        curval_ = brange.rmin() + (frac * delta);
      }
    }

    return(wremain_);
  }

 private:
  BinHistConsumer() {};           /* private to disallow */
  /* data structures */
  BinHistogram<BT,WT>* bins_;     /* bins for the middle region */
  size_t size_;                   /* Size() of bins */
  WT wtotal_;                     /* total bins weight */
  Range range_;                   /* bins range */
  /*
   * the remaining fields change as we consume weight.  since we
   * can consume non-integral amounts of weight, we make wremain_
   * and resid_ doubles.
   */
  double wremain_;                /* remaining weight */
  size_t curloc_;                 /* current location in bins array */
  double resid_;                  /* residual at current location (>= 0) */
  double curval_;                 /* value at current location */
};
}  // namespace carp
}  // namespace pdlfs
